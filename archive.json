{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-04T02:09:40.321496+00:00",
  "repo": "martinthomson/prio-l1-bound-sum",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOM-k-FM6Z3YEi",
      "title": "Validity circuit is not arithmetic",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/issues/1",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The `eval` function of the validity circuit needs to be arithmetic, so it can be evaluated with secret shares of measurements (using gadget polynomials for nonlinear parts). While `decode_from_bit_vector()` is arithmetic, since it just evaluates a linear combination using powers of two, `encode_into_bit_vector()` is not, since it does bitwise operations on the inputs. Instead, this circuit will need to explicitly specify its own `encode()`, `truncate()`, and `decode()` methods (forming an \"affine-aggregatable encoding\") and shift some of the non-arithmetic logic into `encode()`. My thinking is that the encoded measurement will consist of bit-vector-encoded numbers from the input vector, followed by one more bit-vector-encoded number that represents the vector weight that the client claims the measurement has. Then the validity circuit can do two things: a range check, that all encoded measurement field elements are 0 or 1, and a sum check, doing `decode_from_bit_vector()` to recover the measurement vector and the claimed weight, then subtracting them to confirm they are equal. We could return both of these checks out of the circuit, note that this would require setting `EVAL_OUTPUT_LEN = 2`. Implementing the validity checks this way is all arithmetic, (and only the range checks require nonlinear gadgets) so they're all possible to do on secret shares. Since the claimed vector weight gets encoded as a bit vector, and we check that each 'bit' is 0 or 1, the circuit will confirm that the vector weight is in [0, 2^bits).\r\n\r\nI can send a PR with these changes.",
      "createdAt": "2024-10-11T13:48:13Z",
      "updatedAt": "2024-10-14T23:42:41Z",
      "closedAt": "2024-10-14T23:42:41Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOM-k-FM6Z3bbl",
      "title": "Reference implementation and test vectors",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/issues/2",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It would be helpful to have a reference implementation of this Prio3 variant, making use the same Python snippets that are in the spec. This would allow testing and production of test vectors. The [PINE VDAF](https://github.com/junyechen1996/draft-chen-cfrg-vdaf-pine) can serve as an example of how to install, import, and extend the VDAF reference implementation.\r\n\r\nI can help out with a PR implementing this.",
      "createdAt": "2024-10-11T13:53:26Z",
      "updatedAt": "2025-05-01T23:11:49Z",
      "closedAt": "2025-05-01T23:11:49Z",
      "comments": [
        {
          "author": "jimouris",
          "authorAssociation": "NONE",
          "body": "We are also considering including this validity circuit to [Mastic](https://github.com/jimouris/draft-mouris-cfrg-mastic).",
          "createdAt": "2024-10-29T17:32:48Z",
          "updatedAt": "2024-10-29T17:32:48Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOM-k-FM603DBp",
      "title": "Update VDAF reference",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/issues/7",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was written when draft-irtf-cfrg-vdaf-12 was current, but the reference in the draft text is unversioned, `I-D.irtf-cfrg-vdaf`. We should pin the draft version and check if section numbers need to be updated.\n\nPR #4 also pulls in the proof of concept implementation, using the draft 12 git tag currently. When we update this, we can just use Python instead of Sage to run the code.",
      "createdAt": "2025-05-01T17:28:25Z",
      "updatedAt": "2025-05-01T17:28:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOM-k-FM603DgO",
      "title": "Pick VDAF algorithm ID",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/issues/8",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We will need to pick a VDAF algorithm ID at some point. Currently, we are using 0xFFFF0000, from the \"Reserved for Private Use\" range.",
      "createdAt": "2025-05-01T17:29:42Z",
      "updatedAt": "2025-05-01T17:29:42Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOM-k-FM5-Wofv",
      "title": "Rewrite the description of L1BoundSum",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/3",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This closes #1. I also adopted an editorial change from the editor's copy of VDAF (coming soon to draft 13) to remove the parameter table and put initialization, `encode()`, `eval()`, `truncate()`, and `decode()` together in one sourcecode element.",
      "createdAt": "2024-10-11T14:56:19Z",
      "updatedAt": "2025-04-30T20:06:55Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "f0ad1e91607e83f36ce9a7c634a1a0fafea18e0b",
      "headRepository": "divergentdave/prio-l1-bound-sum",
      "headRefName": "david/reimplement-circuit",
      "headRefOid": "f860042aa2877306abcbc804f74f4c5044d572c7",
      "closedAt": "2024-10-14T23:42:40Z",
      "mergedAt": "2024-10-14T23:42:40Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "70fbbb51f617e748d2b955a8c3fac7817e4b115e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM-k-FM6M95Sj",
          "commit": {
            "abbreviatedOid": "f860042"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks for helping out!  I knew that if I did a bad job, someone would help me do a good job.  I just didn't expect anything so fast.\r\n\r\nI'm going to take this, but it's going to need a bunch of massaging before it looks anything like reasonable in the output.",
          "createdAt": "2024-10-13T23:20:38Z",
          "updatedAt": "2024-10-13T23:29:12Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "So this is not going to render sensibly.  It seems like there is a preprocessing step used in the VDAF draft that this isn't able to use.\r\n\r\nI can see how it would help to have this code somewhere, so that it could be run, but this draft is not going to be able to take the raw python.",
              "createdAt": "2024-10-13T23:20:39Z",
              "updatedAt": "2024-10-13T23:29:12Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n            ceil((length + 1) * bits)\r\n```",
              "createdAt": "2024-10-13T23:21:02Z",
              "updatedAt": "2024-10-13T23:29:12Z"
            },
            {
              "originalPosition": 115,
              "body": "Is there any value in making this `r**2*range_check + r*weight_check` or something similar?  It would increase the consumption of joint randomness, but it seems like we could save a bunch of communication.",
              "createdAt": "2024-10-13T23:23:07Z",
              "updatedAt": "2024-10-13T23:29:12Z"
            },
            {
              "originalPosition": 132,
              "body": "Is this right, or should the encoded data include an encoding of the L1 norm as well?  Like so,\r\n\r\n```suggestion\r\n        for i in range(self.length + 1):\r\n```\r\n\r\nDespite reading the paper and the VDAF draft, I still can't claim to understand these properly.",
              "createdAt": "2024-10-13T23:28:05Z",
              "updatedAt": "2024-10-13T23:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-k-FM6M9-A7",
          "commit": {
            "abbreviatedOid": "f860042"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-13T23:59:04Z",
          "updatedAt": "2024-10-13T23:59:04Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Previous VDAF drafts did just that, in fact.\r\n\r\nWhen we return a vector of length greater than one out of a validity circuit, Prio3 now uses query randomness to create a random linear combination, compressing the two field elements. Thus, the communication cost isn't any different, because there's still one field element for the (reduced) circuit output in the verifier. (The soundness error of this compression is also slightly better, since we're using two query randomness values instead of two powers of one joint randomness value, but that's infinitesimal when dealing with just two output values)",
              "createdAt": "2024-10-13T23:59:04Z",
              "updatedAt": "2024-10-13T23:59:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-k-FM6M9_SK",
          "commit": {
            "abbreviatedOid": "f860042"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T00:02:03Z",
          "updatedAt": "2024-10-14T00:02:03Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "The `truncate()` function converts an encoded measurement (from `encode()`) into an output share, which is what eventually gets added up. We want to drop the last encoded integer, with the claimed weight, because we don't need to add it up when actually doing the aggregation. The extra weight bits in the encoding are just there as a sort of witness to assist in proving the validity of inputs. I should call this out more explicitly.",
              "createdAt": "2024-10-14T00:02:03Z",
              "updatedAt": "2024-10-14T00:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-k-FM6M-7Xp",
          "commit": {
            "abbreviatedOid": "f860042"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T05:08:02Z",
          "updatedAt": "2024-10-14T05:08:02Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I had thought that witness values were propagated.  But I'm realizing now that I have no idea how this works.",
              "createdAt": "2024-10-14T05:08:02Z",
              "updatedAt": "2024-10-14T05:08:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOM-k-FM5-XdI-",
      "title": "Add reference implementation",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/4",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #2, stacked on PR #3.",
      "createdAt": "2024-10-11T17:21:35Z",
      "updatedAt": "2025-05-01T23:59:24Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "4365919e51ea76f9f00db8e7f351757e6c68efab",
      "headRepository": "divergentdave/prio-l1-bound-sum",
      "headRefName": "david/poc",
      "headRefOid": "6cc22fe28bf90fc4e0a12f433ba0b0f70e24e6c3",
      "closedAt": "2025-05-01T23:11:49Z",
      "mergedAt": "2025-05-01T23:11:49Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "e4b3dc38d87bbe1b6a951312ced1c948a071213e"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies for the long delay. I rebased this on main, added a requirements.txt file, and added some documentation covering dependency installation, etc. Note that this currently requires Sage, but newer versions of the VDAF reference implementation only need Python 3.12. I'll file a separate issue for updating the VDAF reference and git tag.",
          "createdAt": "2025-05-01T17:10:11Z",
          "updatedAt": "2025-05-01T17:10:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOM-k-FM6NUXCt",
          "commit": {
            "abbreviatedOid": "f80cb23"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Is there a simple way to test these without having to invoke the entire CI infrastructure?",
          "createdAt": "2024-10-16T00:52:40Z",
          "updatedAt": "2024-10-16T00:55:10Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n      uses: actions/checkout@v4\r\n```",
              "createdAt": "2024-10-16T00:52:40Z",
              "updatedAt": "2024-10-16T00:55:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-k-FM6niuo8",
          "commit": {
            "abbreviatedOid": "6cc22fe"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks David, this is a little bit beyond me, but I like testing, so A1++.",
          "createdAt": "2025-05-01T22:58:04Z",
          "updatedAt": "2025-05-01T22:58:41Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'm not going to pretend that I understand all of these unlabeled parameters, but I will observe that they are unlabeled and that is not good.  The effect is that this is effectively write-only code, because you need a ton of context to understand any part of it.  That is a bit unfortunate; I'd encourage you to spend some time on improving that, though realize that this is a part of a much larger framework that would also need to move, so it's unlikely.",
              "createdAt": "2025-05-01T22:58:04Z",
              "updatedAt": "2025-05-01T22:58:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOM-k-FM6ni8jF",
          "commit": {
            "abbreviatedOid": "6cc22fe"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T23:59:23Z",
          "updatedAt": "2025-05-01T23:59:24Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Fair point, I've been leaning on my IDE for this. Python lets me specify positional arguments as keyword arguments, so I'll go through and do that in a follow-up.",
              "createdAt": "2025-05-01T23:59:24Z",
              "updatedAt": "2025-05-01T23:59:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOM-k-FM5-54TH",
      "title": "Add David as co-author",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/5",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@divergentdave, you should have a collaboration invitation in your inbox as well.",
      "createdAt": "2024-10-17T01:49:47Z",
      "updatedAt": "2024-10-18T06:49:57Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "8cc18e8139d82565dff96fea423ccc84f10eb68c",
      "headRepository": "martinthomson/prio-l1-bound-sum",
      "headRefName": "david-author",
      "headRefOid": "ed2e2eb40d48e969101437ce25a0fd785d506121",
      "closedAt": "2024-10-18T06:49:57Z",
      "mergedAt": "2024-10-18T06:49:57Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "ed2e2eb40d48e969101437ce25a0fd785d506121"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOM-k-FM5_JK8-",
      "title": "Fix a bracket",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/6",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes an unbalanced bracket in the `decode()` method.",
      "createdAt": "2024-10-18T20:32:56Z",
      "updatedAt": "2024-10-21T00:50:45Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "ed2e2eb40d48e969101437ce25a0fd785d506121",
      "headRepository": "martinthomson/prio-l1-bound-sum",
      "headRefName": "david/fix-bracket",
      "headRefOid": "2dc84fc3fceffd7dfb893133f5ddaff754ed0fd4",
      "closedAt": "2024-10-21T00:48:28Z",
      "mergedAt": "2024-10-21T00:48:27Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "25b15a776d781411fdcfe94283b46958d9e94713"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM-k-FM6N5wI_",
          "commit": {
            "abbreviatedOid": "2dc84fc"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-21T00:48:23Z",
          "updatedAt": "2024-10-21T00:48:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOM-k-FM6Uqpty",
      "title": "Editorial changes",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/9",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes a couple small editorial changes. I'd like to avoid using \"measurement\" to refer to the output of the truncate function, to avoid confusion. The description of the FLP interface in the VDAF spec uses the phrase \"aggregatable output\", while in the broader context of Prio3, this becomes the \"output share\" as defined by the VDAF interface.",
      "createdAt": "2025-05-01T17:34:20Z",
      "updatedAt": "2025-05-02T01:07:26Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "4365919e51ea76f9f00db8e7f351757e6c68efab",
      "headRepository": "martinthomson/prio-l1-bound-sum",
      "headRefName": "david/editorial",
      "headRefOid": "61ea56c2d6429f9127dfc431fd1a289e36fe0cf9",
      "closedAt": "2025-05-02T01:07:26Z",
      "mergedAt": "2025-05-02T01:07:26Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "773f1d60bf7d5a1e703dd378710d24b4cbeddb7b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM-k-FM6njIgZ",
          "commit": {
            "abbreviatedOid": "61ea56c"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-05-02T01:07:20Z",
          "updatedAt": "2025-05-02T01:07:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOM-k-FM6UspjL",
      "title": "Clarify magic numbers",
      "url": "https://github.com/martinthomson/prio-l1-bound-sum/pull/10",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds some argument names and variable names to clarify what's going on in the VDAF tests.",
      "createdAt": "2025-05-02T00:03:32Z",
      "updatedAt": "2025-05-02T01:06:39Z",
      "baseRepository": "martinthomson/prio-l1-bound-sum",
      "baseRefName": "main",
      "baseRefOid": "e4b3dc38d87bbe1b6a951312ced1c948a071213e",
      "headRepository": "martinthomson/prio-l1-bound-sum",
      "headRefName": "david/constructor-kwargs",
      "headRefOid": "6b8e23350475344b89096687be28bd87a5df2a3a",
      "closedAt": "2025-05-02T01:06:39Z",
      "mergedAt": "2025-05-02T01:06:38Z",
      "mergedBy": "martinthomson",
      "mergeCommit": {
        "oid": "b0284e049c8cfad503f9cb6317ef7857c6a2bfc5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM-k-FM6njIY4",
          "commit": {
            "abbreviatedOid": "6b8e233"
          },
          "author": "martinthomson",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Much appreciated, thanks.",
          "createdAt": "2025-05-02T01:06:34Z",
          "updatedAt": "2025-05-02T01:06:34Z",
          "comments": []
        }
      ]
    }
  ]
}